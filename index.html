<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<link rel="stylesheet" href="styles.css" />
		<title>McRoulette!</title>
		<script src="Winwheel.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.5/dist/gsap.min.js"></script>
	</head>

	<body>
		<audio src="reward.wav" id="winsound"></audio>
		<main>
			<section class="container">
				<div class="wheelContainer">
					<canvas id="myCanvas" width="500" height="500"> Canvas not supported, use another browser. </canvas>
				</div>

				<div id="interactiveArea" class="interactiveContainer">
					<div class="prizeContainer">
						<h3>{{winningOption.text}}</h3>
					</div>
					<div class="textAreaContainer">
						<textarea id="textArea" cols="30" rows="10" v-model="optionsText" @keydown="onEnter"></textarea>
						<button class="spinButton" @click="theWheel.startAnimation();">Spin the Wheel</button>
						<button class="resetButton" @click="resetWheel()">Reset</button>
					</div>
				</div>
			</section>
			<script type="module">
				import { createApp, ref } from "https://unpkg.com/vue@3/dist/vue.esm-browser.js";
				createApp({
					setup() {
						const optionsText = ref("");
						const winningOption = ref({
							text: "Spin to win!",
							fillStyle: "",
						});
						let segmentCounter = 1;

						const addedOptions = ref([]);

						function onEnter(event) {
							if (event.key === "Enter") {
								const textAreaWords = event.target.value.trim().split("\n");
								addedOptions.value.push(textAreaWords[textAreaWords.length - 1]);
								if (theWheel.segments[1].text === "") {
									for (let i = 0; i < theWheel.segments.length; i++) {
										theWheel.deleteSegment();
									}
									// Si el segmento 1 está vacío (default)
									theWheel.segments[1].fillStyle = "#c20d00";
									theWheel.segments[1].textFillStyle = "#FFF";
									theWheel.segments[1].text = addedOptions.value[addedOptions.value.length - 1];
									theWheel.draw();
									drawTriangle();
									return;
								}
								let lastSegmentAdded = theWheel.addSegment();
								(lastSegmentAdded.text = addedOptions.value[addedOptions.value.length - 1]),
									(lastSegmentAdded.textFillStyle = "#FFF"),
									(lastSegmentAdded.fillStyle =
										theWheel.segments[segmentCounter].fillStyle === "#c20d00" ? "#ffce00" : "#c20d00");
								segmentCounter += 1;
								theWheel.draw();
								drawTriangle();
							}

							if (event.key === "Backspace") {
								if (optionsText.value === "") {
									segmentCounter = 1;
									for (let i = 1; i < 12; i++) {
										i % 2 === 1
											? theWheel.addSegment({ fillStyle: "#ffce00", text: "" })
											: theWheel.addSegment({ fillStyle: "#c20d00", text: "" });
									}
									theWheel.segments[1].text = "";
									theWheel.draw();
									drawTriangle();
								}
								if (optionsText.value[optionsText.value.length - 1] === "\n") {
									const textAreaWords = optionsText.value.trim().split("\n");
									if (!textAreaWords.includes(addedOptions.value[addedOptions.value.length - 1])) {
										addedOptions.value.pop();
										theWheel.deleteSegment();
										theWheel.draw();
									}
								}
							}
						}

						let theWheel = new Winwheel({
							canvasId: "myCanvas",
							numSegments: 12,
							segments: [
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
								{ fillStyle: "#c20d00" },
								{ fillStyle: "#ffce00" },
							],
							lineWidth: 1,
							outerRadius: 170,
							innerRadius: 60,
							textAlignment: "outer", // Set alignment: inner, outer, center.
							animation: {
								type: "spinToStop",
								duration: 5,
								spins: 8,
								// Remember to do something after the animation has finished specify callback function.
								callbackFinished: winAnimation,
								// During the animation need to call the drawTriangle() to re-draw the pointer each frame.
								callbackAfter: drawTriangle,
							},
						});

						// This function called after the spin animation has stopped.
						function winAnimation() {
							// Get the audio with the sound it in, then play.
							let winsound = document.getElementById("winsound");
							winsound.play();
							// Get the number of the winning segment.
							let winningSegmentNumber = theWheel.getIndicatedSegmentNumber();

							winningOption.value.text = theWheel.segments[winningSegmentNumber].text;
							winningOption.value.fillStyle = theWheel.segments[winningSegmentNumber].fillStyle;
							// Loop and set fillStyle of all segments to gray.
							for (let i = 1; i < theWheel.segments.length; i++) {
								if (theWheel.segments[i] !== undefined) {
									theWheel.segments[i].fillStyle = "gray";
								}
							}
							// Make the winning one yellow.
							theWheel.segments[winningSegmentNumber].fillStyle = winningOption.value.fillStyle;
							// Call draw function to render changes.
							theWheel.draw();
							// Also re-draw the pointer, otherwise it disappears.
							drawTriangle();
						}

						function resetWheel() {
							winningOption.value = { text: "Spin to win!", fillStyle: "" };
							theWheel.stopAnimation(false);
							theWheel.rotationAngle = 0;
							for (let i = 1; i < theWheel.segments.length; i++) {
								if (theWheel.segments[i] !== undefined) {
									i % 2 === 1
										? (theWheel.segments[i].fillStyle = "#c20d00")
										: (theWheel.segments[i].fillStyle = "#ffce00");
								}
							}
							theWheel.draw();
							drawTriangle();
						}

						// Function to draw pointer using code (like in a previous tutorial).
						drawTriangle();

						function drawTriangle() {
							// Get the canvas context the wheel uses.
							let ctx = theWheel.ctx;
							ctx.strokeStyle = "white"; // Set line colour.
							ctx.fillStyle = "black"; // Set fill colour.
							ctx.lineWidth = 2;
							ctx.beginPath(); // Begin path.
							ctx.moveTo(220, 50); // Move to initial position.
							ctx.lineTo(280, 50); // Draw lines to make the shape.
							ctx.lineTo(250, 90);
							ctx.lineTo(221, 50);
							ctx.stroke(); // Complete the path by stroking (draw lines).
							ctx.fill(); // Then fill.
						}
						return {
							theWheel,
							optionsText,
							winningOption,
							resetWheel,
							onEnter,
						};
					},
				}).mount("#interactiveArea");
			</script>
		</main>
	</body>
</html>
